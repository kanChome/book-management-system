# 実装計画: 書籍管理システム

**ブランチ**: `001-spec-md` | **日付**: 2025-09-14 | **仕様書**: [spec.md](./spec.md)
**入力**: 機能仕様書 `/specs/001-spec-md/spec.md`

## 実行フロー (/planコマンドスコープ)
```
1. 入力パスから機能仕様を読み込む
   → 見つからない場合: エラー「{path}に機能仕様がありません」
2. 技術コンテキストを埋める（要明確化をスキャン）
   → コンテキストからプロジェクトタイプを検出（web=frontend+backend、mobile=app+api）
   → プロジェクトタイプに基づいて構造を決定
3. 憲法チェックセクションを評価
   → 違反が存在する場合: 複雑性トラッキングに文書化
   → 正当化できない場合: エラー「まずアプローチを簡素化してください」
   → 進捗トラッキングを更新: 初期憲法チェック
4. フェーズ0を実行 → research.md
   → 要明確化が残っている場合: エラー「未知の事項を解決してください」
5. フェーズ1を実行 → contracts、data-model.md、quickstart.md、エージェント固有のテンプレートファイル
6. 憲法チェックセクションを再評価
   → 新しい違反: 設計をリファクタリング、フェーズ1に戻る
   → 進捗トラッキングを更新: 設計後憲法チェック
7. フェーズ2を計画 → タスク生成アプローチを記述（tasks.mdは作成しない）
8. 停止 - /tasksコマンドの準備完了
```

**重要**: /planコマンドはステップ7で停止します。フェーズ2-4は他のコマンドによって実行されます：
- フェーズ2: /tasksコマンドがtasks.mdを作成
- フェーズ3-4: 実装実行（手動またはツール経由）

## 概要
書籍管理システムのバックエンドAPIを構築します。書籍と著者の情報をRDBに登録・更新し、著者に紐づく書籍を取得できる機能を実装します。SpringBoot 3.5.5、JOOQ、クリーンアーキテクチャを使用し、TDD手法で開発を進めます。

## 技術コンテキスト
**言語/バージョン**: Kotlin (Java 21)
**主要依存関係**: SpringBoot 3.5.5、JOOQ、Flyway Migration
**ストレージ**: PostgreSQL
**テスト**: JUnit 5、MockK、TestContainers
**ターゲットプラットフォーム**: Dockerコンテナ（Linux）
**プロジェクトタイプ**: single（バックエンドAPIのみ）
**パフォーマンス目標**: 100 req/s、レスポンスタイム < 200ms (p95)
**制約**: RESTful API、認証なし、削除機能なし
**スケール/スコープ**: 初期段階では小規模（書籍数千件、著者数百名）

## 憲法チェック
*ゲート: フェーズ0リサーチ前に合格必須。フェーズ1設計後に再チェック。*

**簡潔性**:
- プロジェクト: 1（API）
- フレームワークを直接使用？（ラッパークラスなし）はい
- 単一データモデル？（シリアライゼーションが異なる場合を除きDTOなし）はい
- パターンを避ける？（実証された必要性なしにRepository/UoWなし）いいえ - クリーンアーキテクチャを採用

**アーキテクチャ**:
- すべての機能をライブラリとして？（直接のアプリコードなし）はい
- ライブラリリスト:
  - book-domain: 書籍管理ドメインロジック
  - book-adapter: 外部インターフェースアダプター
  - book-application: アプリケーションサービス
- ライブラリごとのCLI: 開発用CLIツールを提供予定
- ライブラリドキュメント: llms.txt形式で計画

**テスト（交渉不可）**:
- RED-GREEN-Refactorサイクル強制？（テストは最初に失敗しなければならない）はい
- Gitコミットは実装前のテストを表示？ はい
- 順序: Contract→Integration→E2E→Unit厳密に従う？ はい
- 実際の依存関係を使用？（モックではなく実際のDB）はい - TestContainers使用
- 統合テスト: 新しいライブラリ、契約変更、共有スキーマ？ はい
- 禁止: テスト前の実装、REDフェーズのスキップ

**可観測性**:
- 構造化ログ含む？ はい（SLF4J + Logback）
- エラーコンテキスト十分？ はい

**バージョニング**:
- バージョン番号割り当て？（MAJOR.MINOR.BUILD）はい - 1.0.0から開始
- BUILDはすべての変更で増加？ はい
- 破壊的変更の処理？（並行テスト、移行計画）N/A - 初期実装

## プロジェクト構造

### ドキュメント（この機能）
```
specs/001-spec-md/
├── plan.md              # このファイル（/planコマンド出力）
├── research.md          # フェーズ0出力（/planコマンド）
├── data-model.md        # フェーズ1出力（/planコマンド）
├── quickstart.md        # フェーズ1出力（/planコマンド）
├── contracts/           # フェーズ1出力（/planコマンド）
└── tasks.md             # フェーズ2出力（/tasksコマンド - /planでは作成しない）
```

### ソースコード（リポジトリルート）
```
# オプション1: 単一プロジェクト（デフォルト）- 採用
src/
├── main/
│   ├── kotlin/
│   │   └── com/example/bookmanagement/
│   │       ├── domain/           # ドメイン層
│   │       │   ├── model/        # エンティティ、値オブジェクト
│   │       │   └── port/         # ポート（インターフェース）
│   │       ├── application/      # アプリケーション層
│   │       │   ├── usecase/      # ユースケース
│   │       │   └── service/      # アプリケーションサービス
│   │       └── adapter/          # アダプター層
│   │           ├── in/           # 入力アダプター
│   │           │   └── web/      # REST API
│   │           └── out/          # 出力アダプター
│   │               └── persistence/  # DB永続化
│   └── resources/
│       ├── application.yml
│       └── db/migration/         # Flyway migration scripts

src/
├── test/
│   ├── kotlin/
│   │   └── com/example/bookmanagement/
│   │       ├── contract/         # 契約テスト
│   │       ├── integration/      # 統合テスト
│   │       └── unit/            # ユニットテスト
│   └── resources/
│       └── application-test.yml

docker/
├── docker-compose.yml           # PostgreSQL、アプリケーション
└── postgres/
    └── init.sql                # 初期化スクリプト

build.gradle                     # Gradleビルド設定
settings.gradle                  # Gradleプロジェクト設定
```

**構造決定**: オプション1（単一プロジェクト）を採用 - バックエンドAPIのみのため

## フェーズ0: アウトラインとリサーチ
1. **技術コンテキストから未知の事項を抽出**:
   - SpringBoot 3.5.5とJOOQの統合ベストプラクティス
   - クリーンアーキテクチャ（buckpalパターン）の実装
   - TestContainersを使用したTDD実践
   - FlywayとJOOQの連携

2. **Context7 MCPを使用した技術リサーチ**:
   ```
   1. Context7 MCPでSpringBoot 3.5.5最新ドキュメント取得
      → SpringBoot 3.5.5の機能と仕様の確認
      → JOOQとの統合パターン調査

   2. Context7 MCPでJOOQベストプラクティス取得
      → JOOQ設定とスキーマ生成の最新手法
      → FlywayマイグレーションとJOOQの連携方法

   3. Context7 MCPでクリーンアーキテクチャ実装パターン取得
      → buckpalパターンのKotlin実装例
      → ドメイン層とアダプター層の設計指針

   4. Context7 MCPでTestContainers最新情報取得
      → PostgreSQL TestContainersの設定
      → TDD実践でのTestContainers活用法
   ```

3. **Context7から得た情報を`research.md`に統合** 形式:
   - 決定: [Context7で調査した最新情報に基づく選択]
   - 根拠: [最新ドキュメントから得られた理由]
   - 検討した代替案: [Context7で調査した他の選択肢]
   - 参照元: [Context7で取得したライブラリ/バージョン情報]

**出力**: Context7 MCPで調査した最新情報に基づくresearch.md

## フェーズ1: 設計と契約
*前提条件: research.md完了*

1. **機能仕様からエンティティを抽出** → `data-model.md`:
   - Book（書籍）: id、title、price、publishStatus
   - Author（著者）: id、name、birthDate
   - BookAuthor（書籍-著者関連）: bookId、authorId
   - バリデーションルール、状態遷移

2. **機能要件からAPI契約を生成**:
   - POST /books - 書籍登録
   - PUT /books/{id} - 書籍更新
   - POST /authors - 著者登録
   - PUT /authors/{id} - 著者更新
   - GET /authors/{id}/books - 著者の書籍取得
   - OpenAPI仕様を`/contracts/`に出力

3. **契約から契約テストを生成**:
   - エンドポイントごとに1つのテストファイル
   - リクエスト/レスポンススキーマのアサート
   - テストは失敗しなければならない（まだ実装なし）

4. **ユーザーストーリーからテストシナリオを抽出**:
   - 各ストーリー → 統合テストシナリオ
   - クイックスタートテスト = ストーリー検証ステップ

5. **エージェントファイルを段階的に更新**:
   - CLAUDE.mdファイルを更新
   - 新しい技術スタック情報を追加
   - 最近の変更を更新（最後の3つを保持）

**出力**: data-model.md、/contracts/*、失敗するテスト、quickstart.md、CLAUDE.md

## フェーズ2: タスク計画アプローチ
*このセクションは/tasksコマンドが何をするかを説明します - /plan中には実行しない*

**タスク生成戦略**:
- `/templates/tasks-template.md`をベースとして読み込む
- フェーズ1の設計ドキュメント（契約、データモデル、クイックスタート）からタスクを生成
- 各契約 → 契約テストタスク [P]
- 各エンティティ → モデル作成タスク [P]
- 各ユーザーストーリー → 統合テストタスク
- テストを通すための実装タスク

**順序付け戦略**:
- TDD順序: 実装前のテスト
- 依存順序: モデル→サービス→UI
- 並列実行のため[P]をマーク（独立したファイル）

**推定出力**: tasks.mdに25-30の番号付き、順序付けされたタスク

**重要**: このフェーズは/tasksコマンドによって実行され、/planではない

## フェーズ3+: 将来の実装
*これらのフェーズは/planコマンドのスコープ外*

**フェーズ3**: タスク実行（/tasksコマンドがtasks.mdを作成）
**フェーズ4**: 実装（憲法原則に従ってtasks.mdを実行）
**フェーズ5**: 検証（テスト実行、quickstart.md実行、パフォーマンス検証）

## 複雑性トラッキング
*憲法チェックに正当化が必要な違反がある場合のみ記入*

| 違反 | なぜ必要か | より簡単な代替案が拒否された理由 |
|-----------|------------|-------------------------------------|
| クリーンアーキテクチャパターン | 明確な責任分離と保守性 | 直接的なDB アクセスではビジネスロジックと永続化が密結合になる |

## 進捗トラッキング
*このチェックリストは実行フロー中に更新される*

**フェーズステータス**:
- [x] フェーズ0: リサーチ完了（/planコマンド）
- [x] フェーズ1: 設計完了（/planコマンド）
- [x] フェーズ2: タスク計画完了（/planコマンド - アプローチのみ記述）
- [ ] フェーズ3: タスク生成（/tasksコマンド）
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

**ゲートステータス**:
- [x] 初期憲法チェック: 合格
- [x] 設計後憲法チェック: 合格
- [x] すべての要明確化解決
- [x] 複雑性の逸脱を文書化

---
*憲法v2.1.1に基づく - `/memory/constitution.md`を参照*